# script to visualize graphs generated by Voreeen (v.5.2.0)
# visualization is based on tubular structures (which do not represent vessels in a bilologically accurate manner, but serve
# as a strating point for graph visualization)

# inspired by
# cf. https://stackoverflow.com/questions/62888678/saving-a-3d-graph-generated-in-networkx-to-vtk-format-for-viewing-in-paraview

import pandas as pd
import numpy as np
import argparse
import os
import vedo as vd
import shutil
from vedo import *
from vtk import * 

def get_values_as_tuple(dict_list, keys):
        return [tuple(d[k] for k in keys) for d in dict_list]   

def dir_path(path):
    if os.path.isdir(path):
        return path
    else:
        raise argparse.ArgumentTypeError(f"readable_dir:{path} is not a valid path")

parser = argparse.ArgumentParser(description='converts voreen csv based graph to vtk files .')
parser.add_argument('-n','--node_list', help='Name of the node list csv file.', required=True)
parser.add_argument('-e','--edge_list', help='Filtering condition: average radius of the vessel.', required=True)
parser.add_argument('-s','--scaling_factor', help='Scaling Factor, default: 1.', default=1.0)
parser.add_argument('-o','--output_directory', help='Output name of converted vtk files.', type=dir_path, required=True)

# define the name of the directory to be created
path = "vtk_tmp/"

try:
    os.mkdir(path)
except OSError:
    print ("Creation of the directory %s failed" % path)
else:
    print ("Successfully created the directory %s " % path)

# holds all graphs
data_list = []

# read the arguments
args = vars(parser.parse_args())

node_path = args['node_list']
edge_path = args['edge_list']
factor = float(args['scaling_factor'])
output_path = os.path.abspath(args['output_directory'])

# 1) nodes

print("Rendering Nodes")
df_nodes = pd.read_csv(node_path,sep=';')

# debugging
# df_nodes.info(verbose=True)

# Node feature matrix with shape [num_nodes, num_node_features]
x = np.array(df_nodes[['degree','isAtSampleBorder']].to_numpy())

# data.pos: Node position matrix with shape [num_nodes, num_dimensions]
pos = np.array( df_nodes[['pos_x', 'pos_y', 'pos_z']].to_numpy())
pos = np.abs(pos)
nodes = vd.Points(pos, r=20).c('red')

# 2) edges:

# remove memory
df_nodes = []
x = []
nodes = []

df_edges = pd.read_csv(edge_path,sep=';')
#df_edges.info(verbose=True)

# Graph connectivity in COO format with shape [2, num_edges] and type torch.long
edge_index = np.array(df_edges[['node1id','node2id']].to_numpy())

# Edge feature  matrix with shape[num_edges, num_edge_features]
#edge_attr_keys = ['length','distance','curveness','avgCrossSection'] # any many more
edge_attr_keys = ['avgRadiusAvg'] # any many more
edge_attr = np.array(df_edges[edge_attr_keys].to_numpy())

edges = []
filenames = []

for i in range (0, len(edge_index)):

     edge_1 = edge_index[i,0]
     edge_2 = edge_index[i,1]
     coord_1 = pos[edge_1]
     coord_2 = pos[edge_2]
     ln = [coord_1,coord_2]
     radius = float(edge_attr[i] / factor)
     t1 = vd.Tube(ln, c="blue", r=radius)
     vd.write(t1,os.path.join(path,f'{i}.vtk'))
     filenames.append(os.path.join(path,f'{i}.vtk'))


reader = vtkPolyDataReader()
append = vtkAppendPolyData()

for file in filenames:
    reader.SetFileName(file)
    reader.Update()
    polydata = vtkPolyData()
    polydata.ShallowCopy(reader.GetOutput())
    append.AddInputData(polydata)

append.Update()    

writer = vtkPolyDataWriter()
vtkname = os.path.commonprefix([node_path,edge_path])
print("common_prefix",vtkname) 
writer.SetFileName(vtkname+f'tube_graph_scaling_factor_{factor}.vtk')
writer.SetInputData(append.GetOutput())
writer.Write()
shutil.rmtree(path)

